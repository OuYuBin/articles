<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1252">
  <title>Java Application Profiling using TPTP</title>
  <link rel="stylesheet" href="default_style.css">
</head>
<body link="#0000ff" vlink="#800080">
<div align="right">&nbsp; <font face="Times New Roman, Times, serif"
 size="2">Copyright © 2006 International Business Machines Corp.</font>
<table border="0" cellpadding="2" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td colspan="2" align="left" bgcolor="#0080c0" valign="top"><b><font
 face="Arial,Helvetica"><font color="#ffffff">&nbsp;Eclipse Corner
Article</font></font></b></td>
    </tr>
  </tbody>
</table>
</div>
<div align="left">
</div>
<p>&nbsp;</p>
<h3>Java Application Profiling using TPTP</h3>
<blockquote> <b>Summary</b> 
<p>The Eclipse Test &amp; Performance Tools Platform (TPTP) Profiling tool
can be used to profile Eclipse plug-ins,
local Java
applications or complex applications running on multiple hosts and
different platforms.
The tool is tightly integrated with Eclipse, allowing profiling of
applications running from within Eclipse. <br>
This article demonstrates how
to use the TPTP Profiling tool to profile
a Java application for identifying execution related hot spots. It
shows
how to start the profiling session, use the various TPTP
views to analyze the data, identify methods with high execution time
then jump to the source code to fix the performance problem.</p>
  <p><b>By Valentina Popescu, IBM</b>
  <br><font size="-1">February 21, 2006</font> </p>
</blockquote>
<hr width="100%"><br>
<img src="images/Idea.jpg" align="right" height="86" width="120">
<h3>Profiling an Application</h3>
<p>In the current environment of short development cycles for delivering a
product, developers tend to focus more on the functional aspects of
application execution, mostly via testing, debugging, and code fixing.
However, many problems do not easily surface until the application is
running in production mode, 24 hours a day, 7 days a week and gets
pushed to limits during some unexpected peak periods. <br>
</p>
<p>
The kinds of performance problems encountered in production cannot be
discovered during a
debugging
session. Before deployed and run in production mode, it is important to
use a Profiling tool to analyze application execution and identify
performance problems, such as execution
bottlenecks, object leaks, and system resource limitations.</p>
<p>
This article provides an introduction to the TPTP
Profiling
tool. It demonstrates how to use the TPTP Profiling tool to profile
a Java application in order to identify performance hot spots,
and fix and validate performance problems.</p>

<h3>TPTP Profiling Tool</h3>
<p>The Eclipse Test &amp; Performance Tools Platform 
<a href="http://eclipse.org/tptp/">(TPTP)</a> Project
offers a profiling tool for identifying and isolating performance
problems such
as performance bottlenecks, object leaks and system resource limits.
The tool
targets applications of all levels of complexity, from simple
standalone Java&trade;
applications to Eclipse plug-ins or complex enterprise
applications running
on multiple
machines and on different platforms.</p>
<p>
Being tightly integrated with the Eclipse project, the tool
is also easy to use and extend. That means that users can plug in their
preferred views to analyze the data, or can extend the data collection
metaphor
by implementing their own flavor of data collection agent.</p>
<p>
This article was written using the TPTP 4.1 based on the EMF 2.1 and
XSD 2.1 release builds, which require Eclipse 3.1. You can download
these drivers from <a href="http://www.eclipse.org/tptp/home/downloads/downloads.php?url=drops/TPTP-4.1.0.html&amp;link=link1">here</a>.
For TPTP 4.1 installation details go to the <a
 href="http://www.eclipse.org/tptp/home/downloads/installguide/InstallGuide41.html">TPTP
download
page</a>.</p>

<h3>Profiling a Java application using TPTP</h3>
<p>The product catalog sample used in this
article
is a simple Java application that parses product
information stored in separate xml files and prints the result to the
console output. The file system location for the folder containing the
product xml files is passed as a program argument when running
the main class, <code>Product.java</code>.
The xml files containing the product information are provided under the
section <a href="#RunningTheExample">running
the example</a>.</p>

<h4>Starting the application in profiling mode</h4>
<p>After installing the sample application, the
first step is to run the product catalog application in profiling mode.
Profile
the application by using the <span style="font-style: italic;">Profile
As &gt; Java Application</span>
popup-menu on the Product class as seen in the image below. </p>

<p align="center"><img
 title="Profile the Product application"
 src="images/n_profileAction.jpg" style="width: 699px; height: 603px;">
 
<br><b>Figure 1</b> Profile the Product catalog Application</p>

<p><img alt="" title="tip"
 src="images/tip.gif">Another way of
starting the application in profiling mode is to use the <span
 style="font-style: italic;">Profile</span>
action available on the Java perspective's toolbar menu. Similar to
the
<span style="font-style: italic;">Run </span>and <span
 style="font-style: italic;">Debug </span>toolbar actions, the <span
 style="font-style: italic;">Profile </span>action will open the
launch configuration dialog and from there you can select the type of
application you want to profile.</p>
<h4>Setting the Java program arguments</h4>
<p>The <span style="font-style: italic;">Profile
As &gt; Java Application </span>action will open the launch
configuration wizard as displayed by Figure 2.</p>

<p>For this example, the folder
containing the product xml files is passed as a program
argument. As described in the Figure 2 below, set the program arguments
to be <span style="font-style: italic;">x:\myPath\products</span>,
where <span style="font-style: italic;">x:\myPath </span>is the path
where you have unzipped the folder containing the product xml files
provided at the end of this article.</p>
<p align="center"><img alt="Set program arguments"
 title="Set program arguments" src="images/n_ArgsTab.jpg"
 style="width: 626px; height: 558px;">
<br><b>Figure 2</b> Product catalog sample - program
arguments</p>

<p style="text-align: left;"><span style="font-weight: bold;"></span></p>
<h4>Setting profiling filters</h4>
<p>The next step is
to set the profiling options to collect method execution information.<br>
To set these options, click the Profile tab on the Launch Configuration
Properties wizard and select an existing profiling set or create a
custom one that better fits the application settings. </p>
<p>
<img alt="" src="images/tip.gif">A Profiling set is a
reusable set of profiling options and filters.
The purpose of creating profiling sets is to reuse them
during consecutive runs of the same application or to share them
between applications that require the same type of profiling
information.</p>
<p>
The steps below describe how to create a new filter set used to
profile the Product catalog application. We will be creating a new
profiling
set named ProductProfiling Set which will be set up to collect detailed
execution information and profile only packages that have the
<span style="font-style: italic;">com.sample.product</span> prefix.</p>

<p style="margin-left: 0.5cm; text-indent: -0.5cm;">1. On the Profiling
Set page enter the name and description of the new
profiling set.
</p>
<div style="text-align: center;"><img
 alt="Define the profiling set name"
 title="Define the profiling set name" src="images/n_pSetP1.jpg"
 style="width: 514px; height: 451px;">
</div>
<p style="text-align: center;"><b style="">Figure 3</b> Profiling set
page</p>
<p>As shown in Figure 3 above we have defined
the ProductProfilingSet that can be used during consecutive runs of the
product catalog applications. On the next run of this application, the
setting profiling filters step can be skipped.</p>

<p style="margin-left: 0.5cm; text-indent: -0.5cm;">2. Choose to
collect execution details by
selecting the Execution Time Analysis option on the Profiling Types
page.</p>
<p style="margin-left: 1cm; text-indent: -0.5cm;">2a. Select the
"Collect
boundary classes excluded by the filter set" option and enter 3 as the
Boundary class depth value. </p>
<p style="margin-left: 1cm;">By selecting this option, you specify that
you want to collect
information for methods invoked to the specified depth starting with
the methods in your filter criteria.</p>
<p style="margin-left: 1cm;">As an example, let's assume that we have
set
the filter to collect information on method MyMethod and to filter out
methods
M1, M2, M3, M4.</p>
<p style="margin-left: 1cm;">If the following invocation stack is
executed: MyMethod &gt; M1 &gt;
M2 &gt; M3 &gt; M4 ( MyMethod invokes M1 which invokes M2 which invokes
M3 which invokes M4 ), based on the filtering criteria selected at
point 2a, the profiler will show this call stack: MyMethod &gt;
M1 &gt; M2 &gt; M3 and will not display the last invocation M3 &gt; M4
(since this exceeds the specified depth of 3).</p>
<p style="text-align: center;"><img alt="Collect execution details"
 title="Collect execution details" src="images/n_pSetP2.jpg"
 style="width: 579px; height: 561px;"><br>
</p>
<p style="text-align: center;"><span style="font-weight: bold;">Figure 4</span>
Choose to collect execution information</p>
<p style="margin-left: 0.5cm; text-indent: -0.5cm;">3. Select the
classes to be profiled.</p>
<p style="margin-left: 0.5cm;">
Use the Filter Set page to choose the classes you want to profile.
There are a set of predefined filters available but for this sample you
will create a new filter set named ProductFilterSet which filters out
everything except packages prefixed by com.sample.product.</p>

<p style="margin-left: 0.5cm;">
Follow these steps to create the filter set:
</p>
<p style="margin-left: 1cm; text-indent: -0.5cm;">3a) Select the Add...
action from the filter set list. In
the result dialog enter ProductFilterSet as the name of the new filter
then click OK</p>
<p style="margin-left: 1cm; text-indent: -0.5cm;">3b) Use the Add...
button from the Contents of selected
filter set list to create the two filters as shown in Figure 5.</p>

<p align="center"><img
 alt="Select the classes to be profiled"
 title="Select the classes to be profiled" src="images/n_pSetP3.jpg"
 style="width: 627px; height: 568px;"><br>
<b>Figure 5</b> Choose classes you want to profile</p>

<h4>Run the application</h4>
<p>Run the Product catalog application by pressing OK on the Launch
Configuration
wizard. Choose Yes when asked to switch to the Profiling and Logging
perspective.</p>
<p>
You should see the result of the program execution in the Console view,
similar with what is presented in Figure 6 below. </p>
<p align="center"><img
 alt="Product application terminated"
 title="Product application terminated" src="images/n_profileApp.jpg"
 style="width: 753px; height: 600px;"><br>
<b>Figure 6</b> Product catalog application has been executed</p>

<p><img alt="" src="images/tip.gif"> The TPTP profiling tool allows you
to
interact with your profiled application. You can pause and resume
monitoring, run garbage collection on the profiled application, collect
object references or terminate the application.</p>

<h4>Identify performance hot spots using the Execution Statistics view</h4>
<p>
Use the Execution Statistics view to identify performance hot spots. To
open this view, select the&nbsp; process in the&nbsp; Profiling Monitor
view and select Open with &gt; Execution Statistics pop-up action.<br>
The Execution Statistic view shown in the Figure 7 below displays the
methods executed, sorted by cumulative time. The cumulative time
for a method is the time spent to execute that method, including
any invocations to other methods.</p>
<p align="center"><img alt="Execution statistics view"
 title="Execution statistics view" src="images/n_executionStat.jpg"
 style="width: 751px; height: 513px;"><br>
<b>Figure 7</b> Execution Statistics View</p>
<p>As presented in Figure 7, the <b>Execution
Statistics</b> shows the main(java.lang.String[]),
readData(java.lang.String) and createParser() methods as the top three
methods with the highest execution time. It is not surprising to see
the main and readData methods on this list since the first one is the
starting point of the application execution while the second as
suggested by it's name, is reading the products data from the xml files.</p>
<p>
What comes as a surprise for us is the fact that createParser()
method, which
just creates a SAX parser instance used to parse
the xml files, has such a high execution time. The execution time for
this method accounts for 42.96% of
the application's total execution time. The Execution Statistics have
helped us to identify this method as a potential place to optimize the
application's performance.</p>
<p>
Once we have identified this, let's drill down and see the
createParser() method's execution details. </p>
<h4>Open Method Invocation Details view on the createParser() method</h4>

<p>We will use next the Method Invocation
Details view to see what methods in the createParser() call stack are
responsible for the method's slow execution time. Open the Method
Invocation Details view by double-click on the createParser() method in
the Execution Statistics view.</p>
<p align="center"><img alt="Method Invocation Details"
 title="Method Invocation Details" src="images/n_mInv.jpg"
 style="width: 844px; height: 705px;"><br>
<b>Figure 8</b> Method Invocation Details view</p>
<p>Figure 8 above presents the execution information for the
createParser() method. As you can see the method has been invoked once
by the readData(java.lang.String) method and invokes 5 different
methods. In the invoked methods table you can see that newSAXParser()
and newInstance() methods are responsible for the createParser's method
slow execution. These two methods were called 24 times, as the
createParser() method has been executed 24 times.</p>
<p>
<h4>Define a solution for the identified performance problem</h4>
<p>
By analyzing this data, we found that one way to improve the
createParser() execution time is to improve the execution of the two
SAXParserFactory methods. Since we have no control over these methods'
implementation, the only way to improve our application execution is to
reduce the number of calls we make to these methods.</p>
<p>
The solution is to create one parser instance and reuse it for parsing
all xml files, instead of creating a new parser for every file. Let's
open the source code and apply the fix.</p>
<p style="text-align: left;"><img alt="" title="tip"
 src="images/tip.gif">Before making
any such optimizations, make sure that they are supported by the code.
For example, while the SAXParser cannot be simultaneously used by
multiple threads, instances can be reused. Strictly speaking, instances
should be <code>reset()</code>before they are reused. It is also a
good idea to have a comprehensive set of unit tests in place before you
make changes to code that could possibly introduce changes in behavior.</p>

<h4>Open the source code and apply the performance fix</h4>
<p>To open the source code for the createParser() method, select the
method in the Method Invocation Details view then right-click and
choose the Open Source action on the pop-up menu.</p>
<p align="center"><img alt="Source code"
 title="Source code" src="images/n_sourceCode.jpg"
 style="width: 815px; height: 693px;"><br>
<b>Figure 9</b> Source code</p>
<p>Figure 9 shows the createParser() source
code. Notice that the method creates a new SAX parser instance on every
call.</p>
<p>
Update the source code as presented in Figure 10 below so that the code
will create only one parser instance and reuse it when parsing every
xml file.</p>
<p align="center"><img alt="Source code"
 title="Source code" src="images/n_sourceCodeFix.jpg"
 style="width: 815px; height: 693px;"><br>
<b>Figure 10 </b> Source code fix</p>
<p>As presented in Figure 10, the performance
fix defines a global SAXPArser instance. ThecreateParser() method
initializes the parser and pass this instance every time the method is
called.</p>
<p>Let's go back now and validate the fix by
running the Product catalog application in profiling mode once again.
</p>
<h4>Validate the performance fix</h4>
<p>To validate the performance fix, select
the Product&nbsp; class in the Java perspective and as described above,
right-click and choose Profile As &gt; Java Application.</p>
<p>The Profiling options wizard will not open
again as the previous profiling options will be used to run the
application. After the application is executed, open the Execution
Statistics view and compare the execution time.</p>
<p>Figure 11 shows the execution times after the fix has been applied to
the code:
</p>
<p align="center"><img alt="Execution Statistics view"
 title="Execution Statistics view" src="images/n_executionStatFix.jpg"
 style="width: 742px; height: 575px;"><br>
<b>Figure 11</b> Execution Statistics view</p>

<p>As you can see in the image above, the createParser() execution time is
now only 19% of the application execution, while before the performance
fix has been applied to the code, the createParser() execution time was
almost 43% of the application execution time.</p>
<p>
Note that this improvement will prove to be even more valuable as the
number of xml files to be parsed increases, so the fix will reduce the
application execution time exponential as more product files are being
added to the catalog.</p>

<h3>Conclusion</h3>
<p>This article has shown how the TPTP profiling tool can be used to
identify and solve performance problems. There are more aspects of the
TPTP tool not covered by this article. If you would like to know more
about the tool's capabilities, there are a set of&nbsp; tutorial slides
and User Guides available <a
 href="http://www.eclipse.org/tptp/home/documents/index.html">here</a>.</p>

<h3><a name="RunningTheExample"></a>Running the example</h3>
<p>The file "<a href="productCatalogSample.zip">ProductCatalog_example.zip</a>"
contains the complete source code for the example in this article.
Extract the content of the ZIP file into the Eclipse "plugins"
directory. You will also need the list of product xml files which are
stored in the <a href="xmlProductFiles.zip">products.zip</a> file.
Extract the
content of the products.zip file to a desired location on your file
system and use this path as a program argument when running the Product
catalog
application.</p>

<p><small>Java and all Java-based trademarks and logos are trademarks
or registered trademarks of Sun Microsystems, Inc. in the United
States, other countries, or both.
</small></p>

</body>
</html>
